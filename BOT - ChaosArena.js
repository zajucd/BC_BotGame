//#region 地图与字符串
const map = {
    "Type": "Always",
    "Tiles": "КККККККККККККККККККККККККККККККККККККККККxxxxxxxxxxxxxxxКxnnnnxКÜÜÜߚߚߚߚÜÜÜÜߚߚߚÜКxxxxxxxxxxxxxxxКxnxxxnxКÜÜߚߚߚߚߚߚÜÜߚߚߚߚߚКxxxxxxxЮxxxxЮxxКxnxxxnxКÜߚߚߤߤߤߤߚߚÜߚߚߚߚߚКxxxxxxxxxxxxxxxКxnxxxnxКÜߚߚߤߤߤߤߚߚÜÜߚߚߚÜКxxxxxxxxxxxxxxxКxnxxxnxКÜߚߚߤߤߤߤߚߚÜÜÜÜÜÜКxxxxxxxxxxxxxxxКxККxККxКÜÜߚߚߚߚߚߚÜÜÜÜÜÜÜКxxxxxxКККККККККÜÜߚÜߚߚКxxxxЮxÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÜߚÜÜߚߚКxxxxxxÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒߚߚÜÜߚߤКxxxxxxÒÒКККККÒÒÒÒÒÒÒÒÒÒÒКëëëКÒÒߚߚÜߚߚߤКxxxxЮxÒÒðððððÒÒÒÒÒÒÒÒÒÒÒКëëëКÒÒߚߚߚߚߤߤКxxxxxxÒÒððКððÒÒÒÒÒÒÒÒÒÒÒКëКëКÒÒÜߚߤߤߤߤКxxxЮxxÒÒðððððÒÒÒÒÒÒÒÒÒÒÒКëëëКÒÒÜߚߚߤߤߤКxxxxxxÒÒКККККÒÒÒÒÒÒÒÒÒÒÒКëëëКÒÒÜÜߚߤߤߤКxxxxxxÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÜÜߚߚߤߤККККККККÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒККККККККddddddКÒÒÒÒÒÒÒÒÒиииииииÒÒÒÒÒÒÒÒÒККnnnnnККÒÒÒÒÒÒÒÒÒККÒÒÒÒÒÒÒÒÒККnnnnnКnddddКÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒКnКdddddКÒÒÒÒÒÒÒÒÒККÒÒÒÒÒÒÒÒÒККnddddКÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒКnКnnnnnККÒÒÒÒÒÒÒÒÒККÒÒÒÒÒÒÒÒÒККnnnnnКddddddКÒÒÒÒÒÒÒÒÒКККККККÒÒÒÒÒÒÒÒÒКККККККККÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒККККККККÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒúúúúúúКААААÒÒКëëëКÒÒÒÒÒÒÒÒÒÒÒКККККÒÒúІúúІúКАÒÒКëëëКÒÒÒÒÒÒÒÒÒÒÒðððððÒÒúІúúІúКААÒÒКëКëКÒÒÒÒÒÒÒÒÒÒÒððКððÒÒúІúúІúКАÒÒКëëëКÒÒÒÒÒÒÒÒÒÒÒðððððÒÒúІúúІúКААААÒÒКëëëКÒÒÒÒÒÒÒÒÒÒÒКККККÒÒúúúúúúКАÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒúІúúІúКААÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒúІúúІúКАКККККККККúІúúІúКААААККККККúúúúúúúúúúІúúІúКААААААААКnnКúІІІІúІІІІІúúІúКААААААКnnКúúúúúúúúúúúúúІúКАААААААКnnКúúúúúúúúúúúúúІúКАААААКnnКúІІІІúІІІІІІІІúКААКnnnnКúúúúúúúúúúúúúúú",
    "Objects": "dddddddddddddddddddddddddddddddddddddddddddddddddddddddddиࠖࠖdࠖࠖиdddddddddddddddddࠖࠖࠖࠖࠖdࠖࠖࠖࠖࠖࠖࠖࠖddиࠖdddࠖиdddddddddddddddddddddࠖddྫdࠖddྫdddиࠖdddࠖиddddddddddddddddddࠖࠖࠖࠖddࠖdࠖddࠖࠖࠖdиࠖdddࠖиdddddddddddddddddddࠖdddࠖࠖdࠖddࠖdddиࠖdddࠖиdddddddddddddddddࠖdࠖdࠖddࠖdࠖࠖdࠖdࠖdиdddddиdddddddddddddddddࠖdddࠖࠖdddddddddddddྴddddddddddddddddddddࠖdddྫddddddddddddddԗddddddddddddddddddddࠖࠖࠖࠖdࠖddࠂddddddddddddddddddddddddddddddddddࠖddddddddddddddddddddddԛԛԛddddddddddddࠖࠖࠖྫࠖdddԝdddԝdddddddddddddddddddddddddddࠖdࠖdࠖdddԝdddԝddddࠂddࠂdddddddddddddddddddࠖdྫdࠖdddԝdddԝdddddddddddddddddddddddddddddࠖdࠖddddddddddddddddddddԛԛԛdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddииииииddd߸dddddddddྪddddd߸dddddddииииииdࠖࠖࠖࠖࠖdddddddddddddddddddddddd߸ddddࠖࠖࠖࠖࠖdࠖdddddࠖdddddࠂdddࠖdddsdࠖdddddddddࠖdddddࠖdddddddྴԖd߸ddddddྪdddddྪdddࠂddddԕྴdddddddࠖdddddࠖdddddddddࠖdndddࠖddd߸dddddࠖdddddࠖdࠖࠖࠖࠖࠖdddddddddddddddddddddddddddddࠖࠖࠖࠖࠖdииииииddࠂddd߸ddddddྪddddd߸dࠂdddddииииииdddddddddddddddddddddddddddddddddddddddddddddddddddddddddd߸ddddddddddddddddʔddʨdddddddddd߸dԚԚԚdddddddddࠂddddddddddddddddddddddddddddddddddddddddddԜdddԜࠂddddʨdddddddddddddddddddddddd߸ddddԜdddԜddddddddddddddddddddddddddddddddࠂddԜdddԜddddddʨdddddddddddddԚԚԚddddddddddddddddddddʔddddʨddddddddddddddddddddddddddddddddddddʨdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddྴddddddddddddddddʨdddddddddddddddddddиdddddиddddddʔddddddddddddddddddddddddddиࠖdddࠖиdʔddddddddddʨddddddddddddddddddddиࠖdddࠖиdddʨddddʨddddddddddddddddddddddddиࠖdddࠖиdddddʨdddddʨdddddddddddddddddddddиࠖdddࠖиdʨdddddddddddddddddddddddddddddddиࠖࠖdࠖࠖиddddddʨddddddddd"
}
const ElementStrings = ["皮革", "金属", "乳胶", "绳索", "治愈"];
const ElementWordToTag = {
    leather: 0,
    leath: 0,
    metal: 1,
    latex: 2,
    rope: 3,
    heal: 4,
}
const BodypartStrings = ["手部", "头部", "腿部", "身体"];
const BodypartAssetGroupStrings = [
    ["ItemArms", "ItemHands"],
    ["ItemMouth", "ItemMouth2", "ItemMouth3", "ItemHead", "ItemNose", "ItemHood", "ItemEars"],
    ["ItemFeet", "ItemLegs", "ItemBoots"],
    ["ItemPelvis", "ItemTorso", "ItemTorso2", "ItemBreast"],
    ["ItemNeck", "ItemNeckAccessories", "ItemNeckRestraints"],
    ["ItemDevices", "ItemAddon"],
    ["ItemVulva", "ItemVulvaPiercings", "ItemButt", "ItemNipples", "ItemNipplesPiercings"]
]
const desc = `
BOT game：ChaosArena
作者: zajucd(7092)
原型: https://github.com/keykey5/BC-BOT-repository
发布地址: https://github.com/zajucd/BC_BotGame

这里是KinkyDungeon的21层，这个房间是治愈神龛(安全区)，你要做的就是绑住所有人然后献祭掉。
神龛位于地图东南西北四个方向的房间内，站在深处的软垫地板上可以献祭带到房间内的祭品获得积分与奖励。(最好只使用BC原本的牵绳功能)
每人有3点法力值，每分钟恢复1点，可以用来释放法术，释放方式见可用指令
被献祭了也没关系，每两分钟会触发一次地图事件，祭品最多的神龛里的祭品会被放出并自动施放强力的女神法术
当然允许互动权限必须是(所有人)或(所有人,除了黑名单成员)才能离开治愈神龛，否则会被自动踢出

可用指令 通过发送(/bot [指令] [参数1] [参数2])来使用
[spell]释放法术，需要两个参数。可用参数见下方英文，两两组合会释放不同法术，自己摸索吧，身体特定部位被绑住会使对应元素的法术无法释放用。leath来代替leather可以少打几个字母
leather   metal   latex   rope   heal
皮革      金属    乳胶    绳索   治愈
手部      头部    腿部    身体   无需部位
例:/bot spell leather metal 为施放皮革金属元素的法术，/bot spell metal rope 为施放金属绳索元素的法术
[think]检查当前状态，不需要参数。
[list]显示排行榜，不需要参数。
[free]消耗3点积分释放自己并回到治愈女神神龛(安全区)，不需要参数。


欧内该Ada桑，如果没有KinkyDungeon的新版本玩的话，瓦塔西！
对了，虽然这里是治愈神龛(安全区)，但是只保护法术的捆绑不保护玩家的捆绑，说不定你在读这行字的时候已经被牵走了
`
//#endregion
//#region 装备
//#region 捕获后装备 
const MetalCatchEquipList = [
    {
        "Item": "HeavyYoke",
        "AssetGroup": "ItemArms",
    },
    {
        "Item": "PolishedMittens",
        "AssetGroup": "ItemHands",
    },
    {
        "Item": "PolishedSteelHood",
        "AssetGroup": "ItemHood",
    },
    {
        "Item": "PolishedChastityBra",
        "AssetGroup": "ItemBreast",
    },
    {
        "Item": "PolishedChastityBelt",
        "AssetGroup": "ItemPelvis",
    },
    {
        "Item": "HeavySpreaderMetal",
        "AssetGroup": "ItemFeet",
    },
    {
        "Item": "MetalBallet",
        "AssetGroup": "ItemBoots",
    },
    {
        "Item": "OneBarPrison",
        "AssetGroup": "ItemDevices",
    },
    
    
]
const RopeCatchEquipList = [
    {
        "Item": "HempRope",
        "AssetGroup": "ItemArms",
        "TypeRecord": { typed: 9 },
    },
    {
        "Item": "HempRopeHarness",
        "AssetGroup": "ItemTorso", 
        "TypeRecord": { typed: 4 },
    },
    {
        "Item": "CeilingRope",
        "AssetGroup": "ItemAddon",
        "TypeRecord": { typed: 2 },
    },
]
const LeatherCatchEquipList = [
    {
        "Item": "QualityHarnessGag",
        "AssetGroup": "ItemMouth",
        "TypeRecord": { typed: 1 },
    },
    {
        "Item": "LeatherHarness", 
        "AssetGroup": "ItemTorso",
    },
    {
        "Item": "PawPaddedPetsuitArms",
        "AssetGroup": "ItemArms",
        "Color": ['#161616', '#EDEDED', '#242424', '#960000', '#370000', '#890000', '#2F2F2F', 'Default', 'Default']
    },
    {
        "Item": "PawPaddedPetsuitLegs",
        "AssetGroup": "ItemLegs",
        "Color": ['#181818', 'Default', '#131313', '#F40000', '#252525', '#323232', '#760000', 'Default', 'Default']
    },
    {
        "Item": "StraponPanties",
        "AssetGroup": "ItemPelvis",
    },
    {
        "Item": "LowCage",
        "AssetGroup": "ItemDevices",
    }
]
const LatexCatchEquipList = [
    {
        "Item": "CustomBallHood",
        "AssetGroup": "ItemHood",
    },
    {
        "Item": "InflatableBodyBag",
        "AssetGroup": "ItemDevices",
    },
]
const RemoveWhenMapEvent = [
    {
        "Item": "OneBarPrison",
        "AssetGroup": "ItemDevices",
    },
    {
        "Item": "CeilingRope",
        "AssetGroup": "ItemAddon",
        "TypeRecord": { typed: 2 },
    },
    {
        "Item": "LowCage",
        "AssetGroup": "ItemDevices",
    }
]
const CatchEquipLists = [LeatherCatchEquipList, MetalCatchEquipList, LatexCatchEquipList, RopeCatchEquipList]
//#endregion
//#region 散件装备
const MetalNormalEquipList = [
    {
        "Item": "FuturisticAnkleCuffs",
        "AssetGroup": "ItemFeet",
        "TypeRecord":{ typed: 1 },
    },
    {
        "Item": "FuturisticLegCuffs",
        "AssetGroup": "ItemLegs",
        "TypeRecord": { typed: 1 },
    },
    {
        "Item": "FuturisticChastityBelt",
        "AssetGroup": "ItemPelvis",
    },
    {
        "Item": "FuturisticBra2",
        "AssetGroup": "ItemBreast",
    },
    {
        "Item": "FuturisticArmbinder",
        "AssetGroup": "ItemArms",
    },
    {
        "Item": "FuturisticMittens",
        "AssetGroup": "ItemHands",
    },
    {
        "Item": "FuturisticHarnessPanelGag",
        "AssetGroup": "ItemMouth",
    },
    {
        "Item": "InteractiveVRHeadset",
        "AssetGroup": "ItemHead",
        "TypeRecord": { b: 0, f: 1, g: 0 },
    },
    {
        "Item": "FuturisticHeels2",
        "AssetGroup": "ItemBoots",
    },
];
const RopeNormalEquipList = [
    {
        "Item": "HempRope",
        "AssetGroup": "ItemFeet",
        "TypeRecord": { typed: 2 },
    },
    {
        "Item": "HempRope",
        "AssetGroup": "ItemLegs",
        "TypeRecord": { typed: 2 },
    },
    {
        "Item": "HempRope",
        "AssetGroup": "ItemPelvis",
        "TypeRecord": { typed: 3 },
    },
    {
        "Item": "HempRopeHarness",
        "AssetGroup": "ItemTorso",
        "TypeRecord": { typed: 4 },
    },
    {
        "Item": "HempRope",
        "AssetGroup": "ItemArms",
        "TypeRecord": { typed: 1 },
    },
    {
        "Item": "RopeGag",
        "AssetGroup": "ItemMouth",
    },
    {
        "Item": "RopeBlindfold",
        "AssetGroup": "ItemHead",
    },
    {
        "Item": "ToeTie",
        "AssetGroup": "ItemBoots",
    },
];
const LeatherNormalEquipList = [
    {
        "Item": "LeatherMittens",
        "AssetGroup": "ItemHands",
    },
    {
        "Item": "ShinyArmbinder",
        "AssetGroup": "ItemArms",
    },
    {
        "Item": "HarnessBallGag",
        "AssetGroup": "ItemMouth",
    },
    {
        "Item": "LeatherBlindfold",
        "AssetGroup": "ItemHead",
    },
    {
        "Item": "LeatherBreastBinder",
        "AssetGroup": "ItemBreast",
    },
    {
        "Item": "LeatherBelt",
        "AssetGroup": "ItemFeet",
    },
    {
        "Item": "LegBinder",
        "AssetGroup": "ItemLegs",
    },
    {
        "Item": "LeatherChastityBelt",
        "AssetGroup": "ItemPelvis",
    },
    {
        "Item": "BalletWedges",
        "AssetGroup": "ItemBoots",
    },
];
const LatexNormalEquipList = [
    {
        "Item": "KneeOvernighter",
        "AssetGroup": "ItemFeet",
    },
    {
        "Item": "SeamlessLegBinder",
        "AssetGroup": "ItemLegs",
    },
    {
        "Item": "PortalPanties",
        "AssetGroup": "ItemPelvis",
    },
    {
        "Item": "TickleBra",
        "AssetGroup": "ItemBreast",
    },
    {
        "Item": "BoxTieArmbinder",
        "AssetGroup": "ItemArms",
    },
    {
        "Item": "LatexBondageMitts",
        "AssetGroup": "ItemHands",
        "TypeRecord": { t: 2, w: 1, r: 0, l: 0 },
    },
    {
        "Item": "LatexBallMuzzleGag",
        "AssetGroup": "ItemMouth",
    },
    {
        "Item": "LatexBlindfold",
        "AssetGroup": "ItemHead",
    },
    {
        "Item": "BalletMittens",
        "AssetGroup": "ItemBoots",
        "TypeRecord": { p: 2 },
    },
];
const NormalEquipLists = [LeatherNormalEquipList, MetalNormalEquipList, LatexNormalEquipList, RopeNormalEquipList]
//#endregion
//#endregion
//#region 地图区域

//#region 四角区域
const LeftUpZone = {
    Areas: [
        { leftUp: { X: 1, Y: 1 }, rightDown: { X: 15, Y: 6 } },
        { leftUp: { X: 1, Y: 7 }, rightDown: { X: 6, Y: 15 } }
    ],
    Exclude: [
    ],
}
const RightUpZone = {
    Areas: [
        { leftUp: { X: 25, Y: 1 }, rightDown: { X: 39, Y: 6 } },
        { leftUp: { X: 34, Y: 7 }, rightDown: { X: 39, Y: 15 } }
    ],
    Exclude: [
    ],
}
const LeftDownZone = {
    Areas: [
        { leftUp: { X: 1, Y: 25 }, rightDown: { X: 6, Y: 33 } },
        { leftUp: { X: 1, Y: 34 }, rightDown: { X: 15, Y: 39 } }
    ],
    Exclude: [
    ],
}
const RightDownZone = {
    Areas: [
        { leftUp: { X: 34, Y: 25 }, rightDown: { X: 39, Y: 33 } },
        { leftUp: { X: 25, Y: 34 }, rightDown: { X: 39, Y: 39 } }
    ],
    Exclude: [
    ],
}
//#endregion
//#region 献祭区域
//#region 上
const UpOfferingZone = {
    Areas: [
        { leftUp: { X: 19, Y: 2 }, rightDown: { X: 21, Y: 5 } },
    ],
    Exclude: [
    ],
}
const UpOfferedZone = {
    Areas: [
        { leftUp: { X: 17, Y: 1 }, rightDown: { X: 17, Y: 6 } },
        { leftUp: { X: 23, Y: 1 }, rightDown: { X: 23, Y: 6 } },
    ],
    Exclude: [
    ],
}
const UpSacrificeZone = {
    Areas: [
        { X: 20, Y: 1 },
    ],
    Exclude: [
    ],
    LinkedZone: [UpOfferingZone, UpOfferedZone],
    Tag: 1,
    MoveTo: { X: 20, Y: 8 },
    Enter: window["UpSacrificeZoneEnter"],
}
async function UpSacrificeZoneEnter(player, params) {
    SacrificeZoneEnter(player, params, UpSacrificeZone);
}
//#endregion
//#region 左
const LeftOfferingZone = {
    Areas: [
        { leftUp: { X: 2, Y: 19 }, rightDown: { X: 5, Y: 21 } },
    ],
    Exclude: [
    ],
}
const LeftOfferedZone = {
    Areas: [
        { leftUp: { X: 1, Y: 17 }, rightDown: { X: 6, Y: 17 } },
        { leftUp: { X: 1, Y: 23 }, rightDown: { X: 6, Y: 23 } },
    ],
    Exclude: [
    ],
}
const LeftSacrificeZone = {
    Areas: [
        { X: 1, Y: 20 },
    ],
    Exclude: [
    ],
    LinkedZone: [LeftOfferingZone, LeftOfferedZone],
    Tag: 3,
    MoveTo: { X: 8, Y: 20 },
    Enter: window["LeftSacrificeZoneEnter"],
}
async function LeftSacrificeZoneEnter(player, params) {
    SacrificeZoneEnter(player, params, LeftSacrificeZone);
}
//#endregion
//#region 右
const RightOfferingZone = {
    Areas: [
        { leftUp: { X: 35, Y: 19 }, rightDown: { X: 38, Y: 21 } },
    ],
    Exclude: [
    ],
}
const RightOfferedZone = {
    Areas: [
        { leftUp: { X: 34, Y: 17 }, rightDown: { X: 39, Y: 17 } },
        { leftUp: { X: 34, Y: 23 }, rightDown: { X: 39, Y: 23 } },
    ],
    Exclude: [
    ],
}
const RightSacrificeZone = {
    Areas: [
        { X: 39, Y: 20 },
    ],
    Exclude: [
    ],
    LinkedZone: [RightOfferingZone, RightOfferedZone],
    Tag: 0,
    MoveTo: { X: 32, Y: 20 },
    Enter: window["RightSacrificeZoneEnter"],
}
async function RightSacrificeZoneEnter(player, params) {
    SacrificeZoneEnter(player, params, RightSacrificeZone);
}
//#endregion
//#region 下
const DownOfferingZone = {
    Areas: [
        { leftUp: { X: 19, Y: 35 }, rightDown: { X: 21, Y: 38 } },
    ],
    Exclude: [
    ],
}
const DownOfferedZone = {
    Areas: [
        { leftUp: { X: 17, Y: 34 }, rightDown: { X: 17, Y: 39 } },
        { leftUp: { X: 23, Y: 34 }, rightDown: { X: 23, Y: 39 } },
    ],
    Exclude: [
    ],
}
const DownSacrificeZone = {
    Areas: [
        { X: 20, Y: 39 },
    ],
    Exclude: [
    ],
    LinkedZone: [DownOfferingZone, DownOfferedZone],
    Tag: 2,
    MoveTo: { X: 20, Y: 32 },
    Enter: window["DownSacrificeZoneEnter"],
}
async function DownSacrificeZoneEnter(player, params) {
    SacrificeZoneEnter(player, params, DownSacrificeZone);
}
//#endregion
async function SacrificeZoneEnter(player, params, zone) {
    SendText("祭品将在5秒后献祭给" + ElementStrings[zone.Tag] + "女神，请勿乱动并稍等，乱动会被献祭", player, false);
    await sleep(5000);
    var offerings = GetSelectAndSortedPlayers((a) => IsInZone(a.Pos, zone.LinkedZone[0]));
    if (offerings.length > 0) {
        let sacrificeFail = false;
        for (let offering of offerings) {
            if (offering.fail == true) {
                sacrificeFail = true;
            }
            await PlayerSacrificed(offering, zone);
            await sleep(1000);
        }
        if (sacrificeFail) {
            SendText("献祭了已经被献祭的祭品，献祭失败，自己成为了祭品", player, false);
        }
        else {
            SendText("献祭成功，" + ElementStrings[zone.Tag] + "女神赐予你" + offerings.length + "积分", player, false);
            player.score += offerings.length;
            if (offerings.length >= 2) {
                SendText(ElementStrings[zone.Tag] + "女神赐予你额外奖励:一次" + ElementStrings[zone.Tag] + "法术免费施法", player, false);
                player.freeSpell[zone.Tag] += 1;
            }
            if (offerings.length >= 3) {
                SendText(ElementStrings[zone.Tag] + "女神赐予你额外奖励:解除" + BodypartStrings[zone.Tag] + "部位束缚", player, false);
                RemoveRestrainsWithAssetGroup(ChatRoomGetCharacter(player.MemberNumber), BodypartAssetGroupStrings[zone.Tag]);
            }
            console.log("Sacrifice:" + ChatRoomGetCharacter(player.MemberNumber).Name);
        }
        
    }
    else {
        SendText("没有祭品，献祭失败，自己成为了祭品", player, false);
        PlayerSacrificed(player, zone);
    }
}
async function PlayerSacrificed(player, zone) {
    player.fail = true;
    RemoveRestrains(ChatRoomGetCharacter(player.MemberNumber));
    await sleep(1000);
    WearEquips(player, CatchEquipLists[zone.Tag], true, true, 1000);
    if ((zone.LinkedZone[1].TileArray ?? false) == false) {
        zone.LinkedZone[1].TileArray = ZoneToTileArray(zone.LinkedZone[1], true);
    }
    let teleported = false;
    for (let tile of zone.LinkedZone[1].TileArray) {
        let used = false;
        for (let char of ChatRoomCharacter) {
            if (IsAtTile(char.MapData.Pos, tile)) {
                used = true;
                break;
            }
        }
        if (used == false) {
            teleported = true;
            Teleport(player, tile.X, tile.Y);
            break;
        }
    }
    if (teleported == false) {
        Teleport(player, 20, 20);
    }
    SendText("被献祭了，可使用[/bot free]指令消耗3积分逃脱，或等待地图事件自动释放", player, false);
    console.log("Be Sacrificed:" + ChatRoomGetCharacter(player.MemberNumber).Name);
}
//#endregion
//#region 箭头区域
const UpArrowZone = {
    Areas: [
        { leftUp: { X: 11, Y: 26 }, rightDown: { X: 13, Y: 26 } },
        { leftUp: { X: 11, Y: 30 }, rightDown: { X: 13, Y: 30 } },
    ],
    Exclude: [
    ],
    Dire: { X: 0, Y: -1 },
    Moved: window["UpArrowZoneMoved"],
}
async function UpArrowZoneMoved(player, params) {
    ArrowZoneMoved(player, params, UpArrowZone.Dire);
}
const LeftArrowZone = {
    Areas: [
        { leftUp: { X: 26, Y: 27 }, rightDown: { X: 26, Y: 29 } },
        { leftUp: { X: 30, Y: 27 }, rightDown: { X: 30, Y: 29 } },
    ],
    Exclude: [
    ],
    Dire: { X: -1, Y: 0 },
    Moved: window["LeftArrowZoneMoved"],
}
async function LeftArrowZoneMoved(player, params) {
    ArrowZoneMoved(player, params, LeftArrowZone.Dire);
}
const RightArrowZone = {
    Areas: [
        { leftUp: { X: 10, Y: 11 }, rightDown: { X: 10, Y: 13 } },
        { leftUp: { X: 14, Y: 11 }, rightDown: { X: 14, Y: 13 } },
    ],
    Exclude: [
    ],
    Dire: { X: 1, Y: 0 },
    Moved: window["RightArrowZoneMoved"],
}
async function RightArrowZoneMoved(player, params) {
    ArrowZoneMoved(player, params, RightArrowZone.Dire);
}
const DownArrowZone = {
    Areas: [
        { leftUp: { X: 27, Y: 10 }, rightDown: { X: 29, Y: 10 } },
        { leftUp: { X: 27, Y: 14 }, rightDown: { X: 29, Y: 14 } },
    ],
    Exclude: [
    ],
    Dire: { X: 0, Y: 1 },
    Moved: window["DownArrowZoneMoved"],
}
async function DownArrowZoneMoved(player, params) {
    ArrowZoneMoved(player, params, DownArrowZone.Dire);
}
async function ArrowZoneMoved(player, params, dire) {
    Teleport(player, player.Pos.X + dire.X, player.Pos.Y + dire.Y);
}
//#endregion
//#region 中间区域

const MiddleZone = {
    Areas: [
        { leftUp: { X: 8, Y: 8 }, rightDown: { X: 32, Y: 32 } },
    ],
    Exclude: [
        { leftUp: { X: 10, Y: 11 }, rightDown: { X: 14, Y: 13 } },
        { leftUp: { X: 27, Y: 10 }, rightDown: { X: 29, Y: 14 } },
        { leftUp: { X: 18, Y: 18 }, rightDown: { X: 22, Y: 22 } },
        { leftUp: { X: 11, Y: 26 }, rightDown: { X: 13, Y: 30 } },
        { leftUp: { X: 26, Y: 27 }, rightDown: { X: 30, Y: 29 } },
    ]
}

const SafeZone = {
    Areas: [
        { leftUp: { X: 18, Y: 18 }, rightDown: { X: 22, Y: 22 } },
    ],
    Exclude: [
    ],
    Enter: window["SafeZoneEnter"],
    Leave: window["SafeZoneLeave"],
}
const LeftUpArrowInsideZone = {
    Areas: [
        { leftUp: { X: 11, Y: 11 }, rightDown: { X: 13, Y: 13 } },
    ],
    Exclude: [
    ],
}
const RightUpArrowInsideZone = {
    Areas: [
        { leftUp: { X: 27, Y: 11 }, rightDown: { X: 29, Y: 13 } },
    ],
    Exclude: [
    ],
}
const LeftDonwArrowInsideZone = {
    Areas: [
        { leftUp: { X: 11, Y: 27 }, rightDown: { X: 13, Y: 29 } },
    ],
    Exclude: [
    ],
}
const RightDonwArrowInsideZone = {
    Areas: [
        { leftUp: { X: 27, Y: 27 }, rightDown: { X: 29, Y: 29 } },
    ],
    Exclude: [
    ],
}
async function SafeZoneEnter(player, params) {
    if (player.inSafeZone == -1) {
        if (player.score > 0) {
            player.score -= 1;
        }
        player.fail = false;
        SendText("已进入治愈女神神龛，若积分不为0则积分减1，在该区域内不会受到法术影响，若在此区域等待3分钟会解除所有束缚", player, false);
        player.inSafeZone = setTimeout(() => { RemoveRestrains(ChatRoomGetCharacter(player.MemberNumber)); }, 180 * 1000);

    }  
}
async function SafeZoneLeave(player, params) {
    clearTimeout(player.inSafeZone);
    player.inSafeZone = -1;
    if (player.AllowedInteractions > 1) {
        SendText("允许互动权限过高，即将踢出", player, false);
        setTimeout(() => { ChatRoomAdminChatAction("Kick", player.MemberNumber.toString()) }, 3 * 1000);

    }
}
//#endregion
//#endregion
//#region 主体事件处理
ChatRoomMessageAdditionDict["ChaosArena"] = function (SenderCharacter, msg, data) { ChatRoomMessageChaosArena(SenderCharacter, msg, data) }
ChatRoomSyncMapDataeAdditionDict["ChaosArena"] = function (SenderCharacter) { CharacterMoved(SenderCharacter) }
async function ChatRoomMessageChaosArena(SenderCharacter, msg, data) {
    if (SenderCharacter.MemberNumber == Player.MemberNumber) {
        return;
    }
    //处理进入信息
    if ((data.Type == "Action") && (msg.startsWith("ServerEnter"))) {
        Teleport(SenderCharacter, 20, 20);
        if (ChatRoomCharacterIsAdmin(SenderCharacter) == false) {
            var player = new PlayerInfo(SenderCharacter);
            players.push(player);
        }
        SendText("这里是KinkyDungeon的21层，这个房间是治愈神龛(安全区)，你要做的就是绑住所有人然后献祭掉。具体规则见BOT的bio，通过发送 /bot think 来测试bot是否生效", SenderCharacter);
        SendText("一句话解释规则说就是绑住其他玩家，然后牵绳牵到东南西北四边的房间里，然后站在里面的软垫地板上", SenderCharacter);

        SendText("还在测试阶段，很可能会有bug", SenderCharacter);
        if (SenderCharacter.AllowedInteractions > 1) {
            SendText("当前允许互动权限过高，若离开治愈神龛将会被踢出，在设置->通用->允许互动中设置", SenderCharacter);

        }
    }
    //处理离开信息
    else if ((msg.startsWith("ServerLeave")) || (msg.startsWith("ServerDisconnect")) || (msg.startsWith("ServerBan")) || (msg.startsWith("ServerKick"))) {
        var index = players.findIndex((a) => a.MemberNumber == SenderCharacter.MemberNumber)
        if (index >= 0) {
            players.splice(index, 1);
        }
    }
    //处理 /bot 信息
    else if ((data.Type == "Hidden" && msg.startsWith("ChatRoomBot"))) {
        console.log(SenderCharacter.Name + " cmd:" + msg)
        var params = msg.toLowerCase().substring(11).trim().split(' ');
        var player = FindPlayer(SenderCharacter);
        if (player != undefined) {
            if (params.length > 0) {
                DoCommands(player, params)
            }
        }
    }
}

async function DoCommands(player, params) {
    if (params.length > 0) {
        switch (params[0]) {
            case "spell": {
                if (params.length < 3) {
                    SpellFail(player);
                }
                else {
                    Spell(player, params[1], params[2]);
                }
            }
                break;
            case "list": {
                ShowList(player);
            }
                break;
            case "think": {
                Think(player);
            }
                break;
            case "free": {
                PayToFree(player);
            }

        }
    }
}
async function Spell(player, param1, param2) {

    if (typeof (ElementWordToTag[param1]) == 'undefined' || typeof (ElementWordToTag[param2]) == 'undefined') {
        SpellFail(player);
        return;
    }
    spellMap.findSpell(ElementWordToTag[param1], ElementWordToTag[param2]).CastSpell(player);
}
async function SpellFail(player) {
    SendText("咒语错误，自己反而被绑了起来，咒语样例：/bot spell leather metal或/bot spell metal rope", player, false);
    let useTag1 = -1;
    if (0.5 - Math.random() > 0) {
        useTag1 = 0;
    }
    else {
        useTag1 = 1;
    }
    let useTag2 = -1;
    if (0.5 - Math.random() > 0) {
        useTag2 = 1;
    }
    else {
        useTag2 = 3;
    }
    WearRamdomEquip(player, useTag1, useTag2);
}
async function ShowList(player) {
    var list = GetSelectAndSortedPlayers((a) => a.fail == false, (a, b) => b.score - a.score);
    SendText("当前排名:", player, false);
    var string = "";
    for (var index in list) {
        string += ((Number.parseInt(index) + 1).toString() + ":" + GetName(list[index].Character) + "," + list[index].score + "分   ");
    }
    SendText(string, player, false);
}

async function Think(player) {
    SendText("积分:" + player.score + ",魔力:" + player.mp + ",免费施法次数:皮革:" + player.freeSpell[0] + "次,金属:" + player.freeSpell[1] + "次,乳胶:" + player.freeSpell[2] + "次,绳索:" + player.freeSpell[3] + "次", player, false);
}
async function PayToFree(player) {
    if (player.score >= 3) {
        player.score - 3;
        player.fail = false;
        player.mp = 3;
        RemoveRestrains(ChatRoomGetCharacter(player.MemberNumber));
        Teleport(player, 20, 20);
        SendText("积分-3，告辞", player, false);
    }
    else {
        SendText("积分不够，等待复活吧", player, false);
    }
}
async function CharacterMoved(SenderCharacter) {
    if (ChatRoomCharacterIsAdmin(SenderCharacter)) {
        return;
    }
    let player = FindPlayer(SenderCharacter);
    let inOfferedZone = false;
    for (let zoneKey in OfferedZoneList) {
        if (IsInZone(SenderCharacter.MapData.Pos, OfferedZoneList[zoneKey])) {
            inOfferedZone = true;
            break;
        }
    }
    if (inOfferedZone == false) {
        player.fail = false;
    }
    for (let zoneKey in AllZoneList) {
        if ((AllZoneList[zoneKey].Enter ?? false) == false &&
            (AllZoneList[zoneKey].Leave ?? false) == false &&
            (AllZoneList[zoneKey].Moved ?? false) == false )
            continue;
        let nowInZone = IsInZone(SenderCharacter.MapData.Pos, AllZoneList[zoneKey])
        let pverInZone = IsInZone(SenderCharacter.MapData.pverPos, AllZoneList[zoneKey])
        if (nowInZone && !pverInZone && (AllZoneList[zoneKey].Enter ?? false)) {
            AllZoneList[zoneKey].Enter(player, null)
        }
        if (!nowInZone && pverInZone && (AllZoneList[zoneKey].Leave ?? false)) {
            AllZoneList[zoneKey].Leave(player, null)
        }
        if (nowInZone && (AllZoneList[zoneKey].Moved ?? false)) {
            AllZoneList[zoneKey].Moved(player, null)
        }
    }
    let triggeredTrapKey = null;
    for (let trapKey in traps) {
        if (IsAtTile(SenderCharacter.MapData.Pos, traps[trapKey].Pos)) {
            triggeredTrapKey = trapKey;
            traps[trapKey].Trigger(player);
            break;
        }
    }
    if (triggeredTrapKey != null) {
        traps.splice(triggeredTrapKey, 1); 
    }

}

async function WearRamdomEquip(player, tag1, tag2, refresh = true, diffcult = 7) {
    let useTag = -1;
    if (0.5 - Math.random() > 0) {
        useTag = tag2;
    }
    else {
        useTag = tag1;
    }

    let randomIndex = Math.floor(Math.random() * NormalEquipLists[useTag].length);
    let randomItem = NormalEquipLists[useTag][randomIndex];
    WearEquips(player, [randomItem], refresh, true, diffcult);
}
async function SetTrap(Pos, tag1, tag2, fullBind = false) {
    traps.push(new trapInfo(Pos, tag1, tag2, fullBind));
}
var timeEventCount = 0;
async function TimeEvent() {
    players = players.filter((p) => ChatRoomGetCharacter(p.MemberNumber) ?? false)
    
    if (timeEventCount >= 1) {
        timeEventCount = 0;
        var lists = [[], [], [], []];
        for (let player of players) {
            if (IsInZone(player.Pos, RightOfferedZone)) {
                lists[0].push(player);
            }
            else if (IsInZone(player.Pos, UpOfferedZone)) {
                lists[1].push(player);
            }
            else if (IsInZone(player.Pos, DownOfferedZone)) {
                lists[2].push(player);
            }
            else if (IsInZone(player.Pos, LeftOfferedZone)) {
                lists[3].push(player);
            }
        }
        let maxIndex = lists.reduce((maxIndex, elem, i, lists) => elem.length > lists[maxIndex].length ? i : maxIndex, 0);
        if (lists[maxIndex].length >= 1) {
            let spell = spellMap.findEvent(maxIndex);
            SendTextToAll("地图事件触发," + ElementStrings[maxIndex] + "神龛内的祭品将被随机投放到场上并在三十秒后释放女神法术:" + spell.text);
            for (let player of lists[maxIndex]) {
                WearEquips(player, CatchEquipLists[maxIndex], false, true, 100);
                RemoveEquips(player, RemoveWhenMapEvent, true, true);
                Teleport(player, Math.floor(Math.random() * 39 + 1), Math.floor(Math.random() * 39 + 1));
                setTimeout(() => { spell.CastSpell(player); }, 30 * 1000);
                await sleep(100);
            }
            console.log("TimeEventFree" + maxIndex.toString())
        }
        else {
            SendTextToAll("所有神龛内的祭品均没有祭品，地图事件触发触发失败，加油抓人啊");
        }
    }
    else {
        timeEventCount++;
    }
    for (let player of players) {
        if (player.mp < 3) {
            player.mp++;
        }
    }
    RemoveTimeOutTrap();
}
async function RemoveTimeOutTrap() {

    traps = traps.filter((a) => (new Date() - a.setedTime) < 10 * 60 * 1000);
}
var EndTimeEvent = false;
async function TimeEventStart() {
    while (EndTimeEvent == false) {
        try {
            TimeEvent();
        }
        catch {

        }
        await sleep(60 * 1000);
    }
}

async function InitRoom() {

    //重置房间
    ChatRoomData.MapData = map;
    ChatRoomData.Description = "[BOT]密室逃生第七部 大乱斗";
    ServerSend("ChatRoomAdmin", { MemberNumber: Player.ID, Room: ChatRoomGetSettings(ChatRoomData), Action: "Update" });
}
//#endregion
//#region 条件判定与玩家查找
function IsInArea(Pos, Area) {
    var isIn = false;
    if (Area.X != undefined) {
        isIn = IsAtTile(Pos, Area);
    }
    else if (Area.leftUp != undefined) {
        isIn = IsInLURD(Pos, Area);
    }
    else if (Area instanceof Array) {
        isIn = IsAtTileArray(Pos, Area);
    }
    return isIn;
}

function IsInZone(Pos, Zone) {
    var isIn = false;
    for (let areaKey in Zone.Areas) {
        if (IsInArea(Pos, Zone.Areas[areaKey])) {
            isIn = true;
            break;
        }
    }
    if (isIn) {
        for (let areaKey in Zone.Exclude) {
            if (IsInArea(Pos, Zone.Exclude[areaKey])) {
                isIn = false;
                break;
            }
        }
    }
    return isIn;
}


function IsAtTile(Pos, Tile) {
    return (Pos.X == Tile.X && Pos.Y == Tile.Y)
}
function IsAtTileArray(Pos, Tiles) {
    for (var tile of Tiles) {
        if (IsAtTile(Pos, tile)) {
            return true;
        }
    }
    return false;
}

/**
 *  判断是否在x*y的范围内
 * @param {any} Pos
 * @param {any} Tile
 * @param {any} x
 * @param {any} y
 * @returns
 */
function IsInXxYBlock(Pos, Tile, x, y) {
    return (Math.abs(Pos.X - Tile.X) < (x / 2)) && (Math.abs(Pos.Y - Tile.Y) < (y / 2));
}
/**
 * 判断是否在周围四个l*w的十字型范围内
 * @param {any} Pos
 * @param {any} Tile
 * @param {any} length
 * @param {any} width
 * @returns
 */
function IsInCrossArea(Pos, Tile, length, width) {
    return (Math.abs(Pos.X - Tile.X) < width && Math.abs(Pos.Y - Tile.Y) < length) ||
        (Math.abs(Pos.Y - Tile.Y) < width && Math.abs(Pos.X - Tile.X) < length)
}
function GetDistance(Pos, Tile) {
    return Math.abs(Pos.X - Tile.X) + Math.abs(Pos.Y - Tile.Y);
} 

var lastUsedZone = null;
function IsInSameZone(Pos, Tile) {
    let foundZone = null;
    if (lastUsedZone != null) {
        if (IsInZone(Pos, lastUsedZone)) {
            foundZone = zone;
        }
    }
    if (foundZone == null) {
        for (let zoneKey in AllZoneList) {
            let zone = AllZoneList[zoneKey];
            if (IsInZone(Pos, zone)) {
                foundZone = zone;
                break;
            }
        }
    }
    if (foundZone != null) {
        return IsInZone(Tile, foundZone);
    }
    return false;
}

function GetEquipCount(player) {
    var char = ChatRoomGetCharacter(player.MemberNumber);
    return char.Appearance.filter((a) => a.Asset.DynamicGroupName.startsWith("Item")).length;
}

function IsInLURD(Pos, LURD) {
    return (Pos.X >= LURD.leftUp.X && Pos.Y >= LURD.leftUp.Y && Pos.X <= LURD.rightDown.X && Pos.Y <= LURD.rightDown.Y)

}
/**
 * 判断 target是否可指定为player的法术目标
 * @param {any} player
 * @param {any} target
 * @param {any} playerCanBeTarget
 * @returns
 */
function IsTargetablePlayer(player, target, playerCanBeTarget = false) {
    if (player.MemberNumber == target.MemberNumber && !playerCanBeTarget) {
        return false;
    }
    if (target.fail == true) {
        return false;
    }
    if (IsInZone(target.Pos, SafeZone)) {
        return false;
    }
    return true;
}

function ZoneToTileArray(Zone, shuffle = false) {
    var array = [];
    for (let Area of Zone.Areas) {
        if (Area.X != undefined) {
            array.push(Area);
        }
        else if (Area.leftUp != undefined) {
            array = array.concat(LURDToTileArray(Area));
        }
        else if (Area instanceof Array) {
            array = array.concat(Area);
        }
    }
    for (let Exclude of Zone.Exclude) {
        let set = null;
        if (Exclude.X != undefined) {
            set = new Set([Exclude]);
        }
        else if (Exclude.leftUp != undefined) {
            set = new Set(LURDToTileArray(Exclude));
        }
        else if (Exclude instanceof Array) {
            set = Exclude;
        }
        array = array.filter(item => !set.has(item));
    }
    if (shuffle) {
        array.sort(() => 0.5 - Math.random());
    }
    return array
}

function LURDToTileArray(LURD) {
    var array = [];
    for (let i = LURD.leftUp.X; i <= LURD.rightDown.X; i++) {
        for (let j = LURD.leftUp.Y; j <= LURD.rightDown.Y; j++) {
            array.push({ X: i, Y: j });
        }
    }
    return array;
}
function FindPlayer(sender) {
    return players.find((a) => a.MemberNumber == sender || a.MemberNumber == sender.MemberNumber);
}

/**
 * 按selectLambda条件选择玩家并按照sortLambda条件排序
 * @param {any} selectLambda
 * @param {any} sortLambda
 * @returns
 */
function GetSelectAndSortedPlayers(selectLambda, sortLambda) {
    var result = [];
    if (selectLambda != null) {
        for (var player of players) {
            if (selectLambda(player))
                result.push(player);
        }
    }
    else {
        result = Object.assign([], players)
    }
    if (sortLambda != null) {
        result.sort(sortLambda);
    }
    return result;

}
//#endregion
//#region 类
class PlayerInfo {
    constructor(sender) {
        this.MemberNumber = sender.MemberNumber;
        this.score = 0;
        this.mp = 3;
        this.freeSpell = [0, 0, 0, 0, 0];
        this.fail = false;
        this.inSafeZone = -1;
    }
    get Pos() {
        var result = ChatRoomGetCharacter(this.MemberNumber);
        if (result != undefined) {
            return ChatRoomGetCharacter(this.MemberNumber).MapData.Pos;
        }
        return { X: 0, Y: 0 };
    }
    get Character() {
        return ChatRoomGetCharacter(this.MemberNumber);
    }
}

class SpellInfo {
    constructor(cost, tag1, tag2, text, func) {
        this.cost = cost;
        this.tag1 = tag1;
        this.tag2 = tag2;
        this.text = text;
        this.func = func;
    }
    async CastSpell(player) {
        let char = ChatRoomGetCharacter(player.MemberNumber);
        //显示法术效果
        SendText(this.text, player, false);
        if (player.fail == true && this.tag1 != 4 && this.tag2 != 4) {
            SendText("祭品无法施法，无法释放", player, false);
            return;
        }
        //免费施法
        if (player.freeSpell[this.tag1] > 0 || player.freeSpell[this.tag2] > 0) {
            let costTag = -1
            if (player.freeSpell[this.tag1] <= 0) {
                costTag = this.tag2;
            }
            else if (player.freeSpell[this.tag2] <= 0) {
                costTag = this.tag1;
            }
            else {
                if (0.5 - Math.random() > 0) {
                    costTag = this.tag2;
                }
                else {
                    costTag = this.tag1;
                }
            }
            if (costTag == -1) {
                console.log(player.MemberNumber + "免费施法错误");
                costTag = 0;
            }
            SendText("消耗了一次" + ElementStrings[costTag] + "法术的免费施法", player, false);
            player.freeSpell[costTag] -= 1;
        }
        //不免费施法
        else {
            if (player.mp < this.cost) {
                SendText("魔力不足，无法释放", player, false);
                return;
            }
            player.mp -= this.cost;
            //治愈法术不需要部位自由
            if (this.tag1 != 4 && this.tag2 != 4) {
                //检查部位是否自由
                for (var bodyPart of BodypartAssetGroupStrings[this.tag1]) {
                    if (InventoryGet(char, bodyPart) != null) {
                        SendText(BodypartStrings[this.tag1] + "被束缚，无法释放，浪费了魔力", player, false);
                        return;
                    }
                }
                for (var bodyPart of BodypartAssetGroupStrings[this.tag2]) {
                    if (InventoryGet(char, bodyPart) != null) {
                        SendText(BodypartStrings[this.tag2] + "被束缚，无法释放，浪费了魔力", player, false);
                        return;
                    }
                }
            }
        }
        this.func(player);
        console.log(char.Name + ":" + this.text)
    }
}

class SpellMap {
    constructor() {
        this.spells = [
            [
                new SpellInfo(2, 0, 0, "皮革扩散:消耗2，对自身5*5范围内的玩家施加一件束缚",
                    async(player) => {
                        let list = GetSelectAndSortedPlayers((a) => IsInXxYBlock(a.Pos, player.Pos, 5, 5) && IsTargetablePlayer(player,a), null);
                        for (let pl of list) {
                            WearRamdomEquip(pl, 0, 0, true);
                            await sleep(100);
                        }
                    }),
                new SpellInfo(1, 0, 1, "舍身冲撞:消耗1，对自身与据自身最近的玩家各施加一件束缚",
                    async (player) => {
                        let list = GetSelectAndSortedPlayers((a) => IsTargetablePlayer(player, a), (a, b) => GetDistance(player, a) - GetDistance(player, b));
                        if (list.length >= 1) {
                            WearRamdomEquip(list[0], 0, 1, true);
                            await sleep(100);
                        }
                        WearRamdomEquip(player, 0, 1, true);
                    }),
                new SpellInfo(2, 0, 2, "匍行阴影:消耗2，在据自身最近的玩家脚下放置一个陷阱",
                    async (player) => {
                        let list = GetSelectAndSortedPlayers((a) => IsTargetablePlayer(player, a), (a, b) => GetDistance(player, a) - GetDistance(player, b));
                        if (list.length >= 1) {
                            SetTrap(list[0].Pos, 0, 2, false);
                        }
                        await sleep(100);
                    }),
                new SpellInfo(1, 0, 3, "命运之绳-阳:消耗1，对一位随机玩家施加一件束缚（可能包括自己）",
                    async (player) => {
                        let list = GetSelectAndSortedPlayers((a) => IsTargetablePlayer(player, a, true), (a, b) => 0.5 - Math.random())
                        if (list.length >= 1) {
                            WearRamdomEquip(list[0], 0, 3, true);
                        }
                        await sleep(100);
                    }),
                new SpellInfo(2, 0, 4, "手部治愈:消耗2，解除手部束缚",
                    async (player) => {
                        RemoveRestrainsWithAssetGroup(ChatRoomGetCharacter(player.MemberNumber), BodypartAssetGroupStrings[0]);
                        await sleep(100);
                    }),

            ],
            [
                null,
                new SpellInfo(2, 1, 1, "金属冲锋:消耗2，长度为7宽度为1的十字范围内的玩家施加一件束缚",
                    async (player) => {
                        let list = GetSelectAndSortedPlayers((a) => IsInCrossArea(a.Pos, player.Pos, 7, 1) && IsTargetablePlayer(player, a), null);
                        for (let pl of list) {
                            WearRamdomEquip(pl, 1, 1, true);
                            await sleep(100);
                        }
                    }),
                new SpellInfo(2, 1, 2, "趁人之危:传送至束缚最多的玩家身边",
                    async (player) => {
                        let list = GetSelectAndSortedPlayers((a) => IsTargetablePlayer(player, a), (a, b) => GetEquipCount(b) - GetEquipCount(a));
                        if (list.length >= 1) {
                            Teleport(player, list[0].Pos.X, list[0].Pos.Y);
                        }
                        await sleep(100);
                    }),
                new SpellInfo(1, 1, 3, "命运之绳-阴:消耗1，传送至随机位置（可能包括祭品区）",
                    async (player) => {
                        Teleport(player, Math.floor(Math.random() * 39 + 1), Math.floor(Math.random() * 39 + 1));
                        await sleep(100);
                    }),
                new SpellInfo(2, 1, 4, "头部治愈:消耗2，解除头部束缚",
                    async (player) => {
                        RemoveRestrainsWithAssetGroup(ChatRoomGetCharacter(player.MemberNumber), BodypartAssetGroupStrings[1]);
                        await sleep(100);
                    }),
            ],
            [
                null,
                null,
                new SpellInfo(2, 2, 2, "乳胶陷阱:消耗1，在据自身脚下放置一个陷阱",
                    async (player) => {
                        SetTrap(player.Pos, 2, 2, false);
                        await sleep(100);
                    }),
                new SpellInfo(3, 2, 3, "混乱陷阱:消耗3，在7*7范围内随机放置7个陷阱",
                    async (player) => {
                        for (let i = 0; i < 7; i++) {
                            SetTrap({ X: player.Pos.X + Math.floor(Math.random() * 7 - 3), Y: player.Pos.Y + Math.floor(Math.random() * 7 - 3) }, 2, 3, false);
                        }
                        await sleep(100);
                    }),
                new SpellInfo(2, 2, 4, "腿部治愈:消耗2，解除腿部束缚",
                    async (player) => {
                        RemoveRestrainsWithAssetGroup(ChatRoomGetCharacter(player.MemberNumber), BodypartAssetGroupStrings[2]);
                        await sleep(100);
                    }),
            ],
            [
                null,
                null,
                null,
                new SpellInfo(3, 3, 3, "绳索爆发:消耗3，当前所在区域所有玩家施加一件束缚（包括自己）",
                    async (player) => {
                        let list = GetSelectAndSortedPlayers((a) => IsInSameZone(player.Pos, a.Pos) && IsTargetablePlayer(player, a, true), null);
                        for (let pl of list) {
                            WearRamdomEquip(pl, 3, 3, true);
                            await sleep(100);
                        }
                    }),
                new SpellInfo(2, 3, 4, "身体治愈:消耗2，解除身体束缚",
                    async (player) => {
                        RemoveRestrainsWithAssetGroup(ChatRoomGetCharacter(player.MemberNumber), BodypartAssetGroupStrings[3]);
                        await sleep(100);
                    }),
            ],
            [
                null,
                null,
                null,
                null,
                new SpellInfo(2, 4, 4, "颈部治愈:消耗2，解除项圈束缚",
                    async (player) => {
                        RemoveRestrainsWithAssetGroup(ChatRoomGetCharacter(player.MemberNumber), BodypartAssetGroupStrings[4]);
                        await sleep(100);
                    }),
            ],

        ];
        this.events = [
            new SpellInfo(0, 4, 4, "发情小狗:7*7范围内的玩家施加完全束缚",
                async (player) => {
                    
                    let list = GetSelectAndSortedPlayers((a) => IsInXxYBlock(a.Pos, player.Pos, 7, 7) && IsTargetablePlayer(player, a), null);
                    for (let pl of list) {
                        WearEquips(pl, LeatherCatchEquipList, true, true, 100);
                        await sleep(100);
                    }
                    player.fail = false;
                    player.mp = 3;
                    Teleport(player, 20, 20);
                    RemoveRestrains(ChatRoomGetCharacter(player.MemberNumber));
                }),
            new SpellInfo(0, 4, 4, "盲目战车:长度为6宽度为3的十字范围内的玩家施加完全束缚",
                async (player) => {
                    let list = GetSelectAndSortedPlayers((a) => IsInCrossArea(a.Pos, player.Pos, 6, 3) && IsTargetablePlayer(player, a), null);
                    for (let pl of list) {
                        WearEquips(pl, MetalCatchEquipList, true, true, 100);
                        await sleep(100);
                    }
                    player.fail = false;
                    player.mp = 3;
                    Teleport(player, 20, 20);
                    RemoveRestrains(ChatRoomGetCharacter(player.MemberNumber));
                }),
            new SpellInfo(0, 4, 4, "蠕胶乳虫:7*7范围内随机放置5个施加完全束缚的陷阱",
                async (player) => {
                    for (let i = 0; i < 5; i++) {
                        SetTrap({ X: player.Pos.X + Math.floor(Math.random() * 7 - 3), Y: player.Pos.Y + Math.floor(Math.random() * 7 - 3) }, 2, 3, true);
                    }
                    await sleep(100);
                    player.fail = false;
                    player.mp = 3;
                    Teleport(player, 20, 20);
                    RemoveRestrains(ChatRoomGetCharacter(player.MemberNumber));
                }),
            new SpellInfo(0, 4, 4, "绳妖入侵:所在区域的玩家施加完全束缚",
                async (player) => {
                    let list = GetSelectAndSortedPlayers((a) => IsInSameZone(player.Pos, a.Pos) && IsTargetablePlayer(player, a, true), null);
                    for (let pl of list) {
                        WearEquips(pl, RopeCatchEquipList, true, true, 100);
                        await sleep(100);
                    }
                    player.fail = false;
                    player.mp = 3;
                    Teleport(player, 20, 20);
                    RemoveRestrains(ChatRoomGetCharacter(player.MemberNumber));
                }),
        ]
        this.defaultSpell = new SpellInfo(0, 4, 4, "测试法术：消耗0，无效果，看到这个说明出bug了",(player)=> {})
    }
    findSpell(tag1, tag2) {
        if (tag1 > tag2) {
            return this.findSpell(tag2, tag1);
        }
        if ((this.spells[tag1][tag2] ?? false) == false) {
            return this.defaultSpell;
        }
        return this.spells[tag1][tag2];
    }
    findEvent(tag) {
        return this.events[tag];
    }
}

class trapInfo {
    constructor(Pos, tag1, tag2, fullBind) {
        this.Pos = Pos;
        this.tag1 = tag1;
        this.tag2 = tag2;
        this.fullBind = fullBind;
        this.setedTime = new Date();
    }
    Trigger(player) {
        if (this.fullBind) {
            WearEquips(player, LatexCatchEquipList)
        }
        else {
            WearRamdomEquip(player, this.tag1, this.tag2);
        }
        SendText("触发了陷阱", player, false);
    }
}
function RegExistPlayer() {
    for (let char of ChatRoomCharacter) {
        if (ChatRoomCharacterIsAdmin(char)) continue;
        players.push(new PlayerInfo(char));
    }
}
async function InitBot() {
    ServerSend("ChatRoomCharacterMapDataUpdate", { Pos: { X: 20, Y: 20 } });
    Player.MapData.Pos = { X: 20, Y: 20 };

    Player.Description = desc;

    InventoryWear(Player, "TheDisplayFrame", "ItemDevices", "Default", 80);
    InventoryLock(Player, "ItemDevices", { Asset: AssetGet("Female3DCG", "ItemMisc", "CombinationPadlock") }, Player.MemberNumber);
    InventoryGet(Player, "ItemDevices").Property.CombinationNumber = "7092";
    // end of description
    ServerSend("AccountUpdate", { Description: Player.Description });
    ChatRoomCharacterUpdate(Player);

}
//#endregion

var players = [];
var spellMap = new SpellMap();
var AllZoneList = {
    LeftUpZone, RightUpZone, LeftDownZone, RightDownZone,
    UpArrowZone, LeftArrowZone, RightArrowZone, DownArrowZone,
    UpOfferingZone, UpOfferedZone, UpSacrificeZone,
    LeftOfferingZone, LeftOfferedZone, LeftSacrificeZone,
    RightOfferingZone, RightOfferedZone, RightSacrificeZone,
    DownOfferingZone, DownOfferedZone, DownSacrificeZone,
    MiddleZone, SafeZone, LeftUpArrowInsideZone, RightUpArrowInsideZone, LeftDonwArrowInsideZone, RightDonwArrowInsideZone
};
var OfferedZoneList = {
    UpOfferedZone,
    LeftOfferedZone,
    RightOfferedZone,
    DownOfferedZone
}
var traps = [];
InitRoom();
InitBot();
RegExistPlayer();
TimeEventStart();
